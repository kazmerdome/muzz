// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: decision.sql

package decisionQuerier

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const count = `-- name: Count :one
SELECT COUNT(*)
FROM decisions
WHERE
  (actor_user_id = $1 OR $1 IS NULL) 
  AND
  (recipient_user_id = $2 OR $2 IS NULL) 
  AND
  (liked_recipient = $3 OR $3 IS NULL)
  AND
  (recipient_likes_actor = $4 OR $4 IS NULL)
`

type CountParams struct {
	ActorUserID         uuid.NullUUID
	RecipientUserID     uuid.NullUUID
	LikedRecipient      sql.NullBool
	RecipientLikesActor sql.NullBool
}

func (q *Queries) Count(ctx context.Context, arg CountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, count,
		arg.ActorUserID,
		arg.RecipientUserID,
		arg.LikedRecipient,
		arg.RecipientLikesActor,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOneByActorUserId = `-- name: GetOneByActorUserId :one
SELECT id, actor_user_id, recipient_user_id, liked_recipient, recipient_likes_actor, created_at FROM decisions
WHERE actor_user_id = $1
`

func (q *Queries) GetOneByActorUserId(ctx context.Context, actorUserID uuid.UUID) (Decision, error) {
	row := q.db.QueryRowContext(ctx, getOneByActorUserId, actorUserID)
	var i Decision
	err := row.Scan(
		&i.ID,
		&i.ActorUserID,
		&i.RecipientUserID,
		&i.LikedRecipient,
		&i.RecipientLikesActor,
		&i.CreatedAt,
	)
	return i, err
}

const getOneByRecipientUserID = `-- name: GetOneByRecipientUserID :one
SELECT id, actor_user_id, recipient_user_id, liked_recipient, recipient_likes_actor, created_at FROM decisions
WHERE recipient_user_id = $1
`

func (q *Queries) GetOneByRecipientUserID(ctx context.Context, recipientUserID uuid.UUID) (Decision, error) {
	row := q.db.QueryRowContext(ctx, getOneByRecipientUserID, recipientUserID)
	var i Decision
	err := row.Scan(
		&i.ID,
		&i.ActorUserID,
		&i.RecipientUserID,
		&i.LikedRecipient,
		&i.RecipientLikesActor,
		&i.CreatedAt,
	)
	return i, err
}

const list = `-- name: List :many
SELECT id, actor_user_id, recipient_user_id, liked_recipient, recipient_likes_actor, created_at
FROM decisions
WHERE
  (actor_user_id = $1 OR $1 IS NULL) 
  AND
  (recipient_user_id = $2 OR $2 IS NULL) 
  AND
  (liked_recipient = $3 OR $3 IS NULL)
  AND
  (recipient_likes_actor = $4 OR $4 IS NULL)
  AND
  (created_at < $5::date OR $5 IS NULL)
ORDER BY created_at DESC
LIMIT $6
`

type ListParams struct {
	ActorUserID         uuid.NullUUID
	RecipientUserID     uuid.NullUUID
	LikedRecipient      sql.NullBool
	RecipientLikesActor sql.NullBool
	PaginationToken     sql.NullTime
	Limit               sql.NullInt32
}

func (q *Queries) List(ctx context.Context, arg ListParams) ([]Decision, error) {
	rows, err := q.db.QueryContext(ctx, list,
		arg.ActorUserID,
		arg.RecipientUserID,
		arg.LikedRecipient,
		arg.RecipientLikesActor,
		arg.PaginationToken,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Decision
	for rows.Next() {
		var i Decision
		if err := rows.Scan(
			&i.ID,
			&i.ActorUserID,
			&i.RecipientUserID,
			&i.LikedRecipient,
			&i.RecipientLikesActor,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertOne = `-- name: UpsertOne :one
INSERT INTO decisions (actor_user_id, recipient_user_id, liked_recipient, recipient_likes_actor, created_at)
VALUES ($1, $2, $3, $4, NOW())
ON CONFLICT (actor_user_id, recipient_user_id)
DO UPDATE SET
    liked_recipient = EXCLUDED.liked_recipient,
    recipient_likes_actor = EXCLUDED.recipient_likes_actor,
    created_at = EXCLUDED.created_at
RETURNING id, actor_user_id, recipient_user_id, liked_recipient, recipient_likes_actor, created_at
`

type UpsertOneParams struct {
	ActorUserID         uuid.UUID
	RecipientUserID     uuid.UUID
	LikedRecipient      bool
	RecipientLikesActor bool
}

func (q *Queries) UpsertOne(ctx context.Context, arg UpsertOneParams) (Decision, error) {
	row := q.db.QueryRowContext(ctx, upsertOne,
		arg.ActorUserID,
		arg.RecipientUserID,
		arg.LikedRecipient,
		arg.RecipientLikesActor,
	)
	var i Decision
	err := row.Scan(
		&i.ID,
		&i.ActorUserID,
		&i.RecipientUserID,
		&i.LikedRecipient,
		&i.RecipientLikesActor,
		&i.CreatedAt,
	)
	return i, err
}
